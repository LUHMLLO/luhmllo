// deno-lint-ignore-file
var Y=class{drifterElement;boundaryElement;options;state;activePointers=new Map;pinchState=null;inertiaFrameId=null;animationFrameId=null;constructor(t,i,e={}){this.drifterElement=t,this.boundaryElement=i,this.options=this.p(e),this.b(),this.state={primaryPointerId:-1,constraints:{minX:0,maxX:0,minY:0,maxY:0},isDragging:!1,isPinching:!1,movement:{offsetX:0,offsetY:0,startX:0,startY:0,velocityX:0,velocityY:0,lastTime:0},zoom:this.options.zoom.initial},this.g(),this.P(),this.t()}p(t){return{dragSpeed:t.dragSpeed??1.25,inertia:{damping:t.inertia?.damping??.92,threshold:t.inertia?.threshold??1},mode:t.mode??"bounded",boundedTo:t.boundedTo??"center",dragTarget:t.dragTarget??"self",zoom:{enabled:t.zoom?.enabled??!0,initial:t.zoom?.initial??1,min:t.zoom?.min??.5,max:t.zoom?.max??1.5,smoothing:t.zoom?.smoothing??.75,zoomTo:t.zoom?.zoomTo??"cursor"}}}b(){if(!this.drifterElement)throw new Error(`Drifter requires a valid HTMLElement, but received: ${this.drifterElement===null?"null":typeof this.drifterElement}`);if(this.options.mode==="bounded"&&!this.boundaryElement)throw new Error("Bounded mode requires a valid boundary element, but none was provided");this.options.mode==="free"&&this.options.dragTarget==="self"&&(this.boundaryElement=null)}g(){this.s=this.s.bind(this),this.n=this.n.bind(this),this.o=this.o.bind(this),this.a=this.a.bind(this),this.r=this.r.bind(this),this.e=this.e.bind(this),this.m=this.m.bind(this)}P(){let t=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_attachEventListeners",t),t.addEventListener("pointerdown",this.s),t.addEventListener("pointermove",this.n),t.addEventListener("pointerup",this.o),t.addEventListener("pointercancel",this.a),t.addEventListener("pointerleave",this.r),globalThis.addEventListener("blur",this.e),globalThis.addEventListener("visibilitychange",this.e),this.options.zoom.enabled&&t.addEventListener("wheel",this.m,{passive:!1})}t(){this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.animationFrameId=requestAnimationFrame(()=>{this.drifterElement.style.setProperty("--translate-x",`${this.state.movement.offsetX}px`),this.drifterElement.style.setProperty("--translate-y",`${this.state.movement.offsetY}px`),this.drifterElement.style.setProperty("--translate-z","0px"),this.drifterElement.style.setProperty("--scale",`${this.state.zoom}`),this.animationFrameId=null})}c(t,i){let e=t.x-i.x,s=t.y-i.y;return Math.sqrt(e*e+s*s)}f(t,i){let e;return this.boundaryElement?e=this.boundaryElement.getBoundingClientRect():e=this.drifterElement.getBoundingClientRect(),{x:(t.x+i.x)/2-e.left,y:(t.y+i.y)/2-e.top}}i(t,i,e=!1){if(this.options.mode==="free"||!this.boundaryElement)return{x:t,y:i};let s=this.drifterElement.clientWidth*this.state.zoom,n=this.drifterElement.clientHeight*this.state.zoom,o=getComputedStyle(this.boundaryElement),a={left:parseFloat(o.paddingLeft),right:parseFloat(o.paddingRight),top:parseFloat(o.paddingTop),bottom:parseFloat(o.paddingBottom)},r=this.boundaryElement.clientWidth-a.left-a.right,m=this.boundaryElement.clientHeight-a.top-a.bottom,h=s/2,l=n/2,d=r/2,c=m/2,v,f,p,u;this.options.boundedTo==="center"?(f=(s-r)/2+d,v=-f,u=(n-m)/2+c,p=-u):(f=d-h,v=-f,u=c-l,p=-u,s>r&&(v=d-h,f=-v),n>m&&(p=c-l,u=-p)),this.state.constraints={minX:v,maxX:f,minY:p,maxY:u};let P=.25;function E(b,g,y){return b<g?e?g+(b-g)*P:g:b>y?e?y+(b-y)*P:y:b}return{x:E(t,v,f),y:E(i,p,u)}}E(){if(this.state.isDragging||this.state.isPinching)return;let{damping:t,threshold:i}=this.options.inertia,e=2e3;this.state.movement.velocityX=Math.max(-e,Math.min(e,this.state.movement.velocityX)),this.state.movement.velocityY=Math.max(-e,Math.min(e,this.state.movement.velocityY));let s=performance.now(),n=o=>{if(!this.inertiaFrameId)return;let a=(o-s)/1e3;if(s=o,this.state.movement.velocityX*=Math.pow(t,a*60),this.state.movement.velocityY*=Math.pow(t,a*60),Math.sqrt(this.state.movement.velocityX**2+this.state.movement.velocityY**2)<i){this.h();return}let m=this.state.movement.velocityX*a,h=this.state.movement.velocityY*a,l=this.i(this.state.movement.offsetX+m,this.state.movement.offsetY+h,!1);this.options.mode==="bounded"&&(l.x!==this.state.movement.offsetX+m&&(this.state.movement.velocityX*=-.3),l.y!==this.state.movement.offsetY+h&&(this.state.movement.velocityY*=-.3)),this.state.movement.offsetX=l.x,this.state.movement.offsetY=l.y,this.t(),this.inertiaFrameId=requestAnimationFrame(n)};this.inertiaFrameId=requestAnimationFrame(n)}h(){this.inertiaFrameId&&(cancelAnimationFrame(this.inertiaFrameId),this.inertiaFrameId=null),this.state.movement.velocityX=0,this.state.movement.velocityY=0}u(){if(this.options.mode==="free")return;let{offsetX:t,offsetY:i}=this.state.movement,e=this.i(t,i,!1);if(Math.abs(e.x-t)<1&&Math.abs(e.y-i)<1)return;let s=performance.now(),n=250,o=a=>{let r=Math.min(1,(a-s)/n),m=r*(2-r);this.state.movement.offsetX=t+(e.x-t)*m,this.state.movement.offsetY=i+(e.y-i)*m,this.t(),r<1&&requestAnimationFrame(o)};requestAnimationFrame(o)}s(t){t.target instanceof HTMLElement&&(this.activePointers.set(t.pointerId,{x:t.clientX,y:t.clientY,timestamp:Date.now()}),this.activePointers.size===1?this.Y(t.clientX,t.clientY,t.pointerId):this.activePointers.size===2&&this.options.zoom.enabled&&this.X(),t.preventDefault())}n(t){this.activePointers.has(t.pointerId)&&this.activePointers.set(t.pointerId,{x:t.clientX,y:t.clientY,timestamp:Date.now()}),this.state.isDragging&&this.state.primaryPointerId===t.pointerId&&this.T(t.clientX,t.clientY),this.state.isPinching&&this.activePointers.size===2&&this.z()}o(t){this.activePointers.delete(t.pointerId),this.state.isPinching&&this.activePointers.size<2?this.l():this.state.isDragging&&this.d(t.pointerId)}a(t){this.activePointers.delete(t.pointerId),this.state.isPinching&&this.l(),this.state.isDragging&&this.d(t.pointerId)}r(t){this.activePointers.delete(t.pointerId),this.state.isDragging&&this.state.primaryPointerId===t.pointerId&&this.d(t.pointerId),this.state.isPinching&&this.activePointers.size<2&&this.l()}e(){this.state.isDragging&&this.d(this.state.primaryPointerId),this.state.isPinching&&this.l(),this.activePointers.clear()}m(t){if(!this.options.zoom.enabled)return;t.preventDefault();let e=1+-t.deltaY/1e3,s=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,this.state.zoom*e));Math.abs(s-this.state.zoom)<.001||this.v(s,t.clientX,t.clientY)}v(t,i,e,s=!0){let n=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_performZoom",n);let o=n.getBoundingClientRect(),a,r;this.options.zoom.zoomTo==="cursor"?(a=i-o.left,r=e-o.top):(a=n.clientWidth/2,r=n.clientHeight/2);let m=(a-n.clientWidth/2-this.state.movement.offsetX)/this.state.zoom,h=(r-n.clientHeight/2-this.state.movement.offsetY)/this.state.zoom,l=a-n.clientWidth/2-m*t,d=r-n.clientHeight/2-h*t;if(s){let c=this.options.zoom.smoothing;this.state.zoom+=(t-this.state.zoom)*c,this.state.movement.offsetX+=(l-this.state.movement.offsetX)*c,this.state.movement.offsetY+=(d-this.state.movement.offsetY)*c}else this.state.zoom=t,this.state.movement.offsetX=l,this.state.movement.offsetY=d;this.t()}Y(t,i,e){this.h(),this.state.isDragging=!0,this.state.movement.startX=t,this.state.movement.startY=i,this.state.primaryPointerId=e,this.state.movement.velocityX=0,this.state.movement.velocityY=0,this.state.movement.lastTime=performance.now();let s=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_beginDrag",s),s.setPointerCapture(e)}X(){if(!this.options.zoom.enabled)return;let t=Array.from(this.activePointers.values());if(t.length!==2)return;this.h(),this.state.isPinching=!0,this.state.isDragging=!1;let[i,e]=t,s=this.f(i,e),n=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_beginPinch",n);let o=(s.x-n.clientWidth/2-this.state.movement.offsetX)/this.state.zoom,a=(s.y-n.clientHeight/2-this.state.movement.offsetY)/this.state.zoom;this.pinchState={initialDistance:this.c(i,e),initialZoom:this.state.zoom,initialCenter:s,initialOffset:{x:this.state.movement.offsetX,y:this.state.movement.offsetY},contentPoint:{x:o,y:a}};let r=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_beginPinch (eventTarget2)",r),this.activePointers.forEach((m,h)=>{r.setPointerCapture(h)})}T(t,i){let e=performance.now(),s=(t-this.state.movement.startX)*this.options.dragSpeed,n=(i-this.state.movement.startY)*this.options.dragSpeed,o=this.state.movement.offsetX,a=this.state.movement.offsetY,r=this.i(this.state.movement.offsetX+s,this.state.movement.offsetY+n,!0);this.state.movement.offsetX=r.x,this.state.movement.offsetY=r.y;let m=e-this.state.movement.lastTime;if(m>5&&m<100){let h=this.state.movement.offsetX-o,l=this.state.movement.offsetY-a;this.state.movement.velocityX=h/m*1e3,this.state.movement.velocityY=l/m*1e3}this.state.movement.startX=t,this.state.movement.startY=i,this.state.movement.lastTime=e,this.t()}z(){if(!this.pinchState||this.activePointers.size!==2)return;let t=Array.from(this.activePointers.values()),[i,e]=t,n=this.c(i,e)/this.pinchState.initialDistance,o=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,this.pinchState.initialZoom*n)),a=this.f(i,e),r=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_processPinchMovement",r);let m=a.x-r.clientWidth/2-this.pinchState.contentPoint.x*o,h=a.y-r.clientHeight/2-this.pinchState.contentPoint.y*o;this.state.zoom=o,this.state.movement.offsetX=m,this.state.movement.offsetY=h,this.t()}d(t){if(this.state.primaryPointerId!==t)return;this.state.isDragging=!1,this.state.primaryPointerId=-1,Math.sqrt(this.state.movement.velocityX**2+this.state.movement.velocityY**2)>this.options.inertia.threshold?this.E():this.options.mode==="bounded"&&this.u();let e=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_endDrag",e),e.hasPointerCapture(t)&&e.releasePointerCapture(t)}l(){this.state.isPinching=!1,this.pinchState=null;let t=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("_endPinch",t),this.activePointers.forEach((i,e)=>{t.hasPointerCapture(e)&&t.releasePointerCapture(e)}),this.options.mode==="bounded"&&this.u()}setZoom(t,i,e,s=!0){let n=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,t));if(Math.abs(n-this.state.zoom)<.001)return;let o=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("setZoom",o);let a=o.getBoundingClientRect(),r=a.left+o.clientWidth/2,m=a.top+o.clientHeight/2;this.v(n,i??r,e??m,s)}getZoom(){return this.state.zoom}resetZoom(t=!0){this.setZoom(this.options.zoom.initial,void 0,void 0,t)}getPosition(){return{x:this.state.movement.offsetX,y:this.state.movement.offsetY}}setPosition(t,i,e=!1){if(e){let s=this.state.movement.offsetX,n=this.state.movement.offsetY,o=performance.now(),a=250,r=m=>{let h=Math.min(1,(m-o)/a),l=h*(2-h),d=this.i(s+(t-s)*l,n+(i-n)*l,!1);this.state.movement.offsetX=d.x,this.state.movement.offsetY=d.y,this.t(),h<1&&requestAnimationFrame(r)};requestAnimationFrame(r)}else{let s=this.i(t,i,!1);this.state.movement.offsetX=s.x,this.state.movement.offsetY=s.y,this.t()}}destroy(){let t=this.options.dragTarget==="self"?this.drifterElement:this.boundaryElement;console.debug("destroy",t),t.removeEventListener("pointerdown",this.s),t.removeEventListener("pointermove",this.n),t.removeEventListener("pointerup",this.o),t.removeEventListener("pointercancel",this.a),t.removeEventListener("pointerleave",this.r),t.removeEventListener("wheel",this.m),globalThis.removeEventListener("blur",this.e),globalThis.removeEventListener("visibilitychange",this.e),this.h(),this.animationFrameId&&cancelAnimationFrame(this.animationFrameId)}};export{Y as Drifter};
