// deno-lint-ignore-file
var Y=class{constructor(t,e,i){if(this.target=typeof t=="string"?document.getElementById(t):t,!this.target||!(this.target instanceof HTMLElement))throw new Error(`Target element not found or invalid: ${t}`);switch(this.options={dragSpeed:1.25,inertiaDamping:.92,inertiaThreshold:1,mode:"bounded",...i,zoom:{enabled:!0,initial:1,min:.5,max:1.5,smoothing:.75,zoomTo:"cursor",...i?.zoom}},this.options.mode){case"bounded":this.boundary=typeof e=="string"?document.getElementById(e):e;break;case"free":this.boundary=globalThis;break}if(!this.boundary||!(this.boundary instanceof HTMLElement))throw new Error(`Boundary element not found or invalid for 'bounded' mode: ${e}`);if(this.options.mode==="bounded"){if(this.boundary===this.target)throw new Error("Boundary element cannot be the same as the target when the mode is 'bounded'. The boundary should be a parent or ancestor element that contains the draggable target.");this.boundary.contains(this.target)}this.state={primaryPointerId:-1,constraints:{boundingX:0,boundingY:0,minX:0,maxX:0,minY:0,maxY:0},isDragging:!1,isPinching:!1,movement:{offsetX:0,offsetY:0,startX:0,startY:0,velocityX:0,velocityY:0,lastTime:0},zoom:this.options.zoom.initial},this.activePointers=new Map,this.pinchState=null,this.animationFrameId=null,this.inertiaFrameId=null,this.e=this.e.bind(this),this.s=this.s.bind(this),this.o=this.o.bind(this),this.n=this.n.bind(this),this.a=this.a.bind(this),this.i=this.i.bind(this),this.h=this.h.bind(this),this.initialize()}initialize(){this.boundary.addEventListener("pointerdown",this.e),this.boundary.addEventListener("pointermove",this.s),this.boundary.addEventListener("pointerup",this.o),this.boundary.addEventListener("pointercancel",this.n),this.boundary.addEventListener("pointerleave",this.a),globalThis.addEventListener("blur",this.i),globalThis.addEventListener("visibilitychange",this.i),this.options.zoom.enabled&&this.boundary.addEventListener("wheel",this.h,{passive:!1}),this.boundary.style.touchAction="none",this.boundary.style.userSelect="none",this.t()}t(){this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.animationFrameId=requestAnimationFrame(()=>{this.target.style.setProperty("--translate-x",`${this.state.movement.offsetX}px`),this.target.style.setProperty("--translate-y",`${this.state.movement.offsetY}px`),this.target.style.setProperty("--translate-z","0px"),this.target.style.setProperty("--scale",`${this.state.zoom}`),this.animationFrameId=null})}p(){if(this.state.isDragging||this.state.isPinching)return;let t=this.options.inertiaDamping??.92,e=this.options.inertiaThreshold??1,i=2e3;this.state.movement.velocityX=Math.max(-i,Math.min(i,this.state.movement.velocityX)),this.state.movement.velocityY=Math.max(-i,Math.min(i,this.state.movement.velocityY));let s=performance.now(),h=o=>{if(!this.inertiaFrameId)return;let n=(o-s)/1e3;s=o,this.state.movement.velocityX*=Math.pow(t,n*60),this.state.movement.velocityY*=Math.pow(t,n*60);let a=this.state.movement.velocityX,r=this.state.movement.velocityY;if(Math.sqrt(a*a+r*r)<e){this.r();return}let c=a*n,m=r*n,d=this.state.movement.offsetX+c,f=this.state.movement.offsetY+m;this.options.mode==="bounded"&&(this.d(d,f,!1),d=this.state.constraints.boundingX,f=this.state.constraints.boundingY,d!==this.state.movement.offsetX+c&&(this.state.movement.velocityX*=-.3),f!==this.state.movement.offsetY+m&&(this.state.movement.velocityY*=-.3)),this.state.movement.offsetX=d,this.state.movement.offsetY=f,this.t(),this.inertiaFrameId=requestAnimationFrame(h)};this.inertiaFrameId=requestAnimationFrame(h)}r(){this.inertiaFrameId&&(cancelAnimationFrame(this.inertiaFrameId),this.inertiaFrameId=null),this.state.movement.velocityX=0,this.state.movement.velocityY=0}d(t,e,i=!0){let s=this.target.clientWidth*this.state.zoom,h=this.target.clientHeight*this.state.zoom,o=getComputedStyle(this.boundary),n={left:parseFloat(o.paddingLeft),right:parseFloat(o.paddingRight),top:parseFloat(o.paddingTop),bottom:parseFloat(o.paddingBottom)},a=this.boundary.clientWidth-n.left-n.right,r=this.boundary.clientHeight-n.top-n.bottom,l=a/2,c=r/2,m=(s-a)/2+l,d=-m,f=(h-r)/2+c,g=-f;this.state.constraints.minX=d,this.state.constraints.maxX=m,this.state.constraints.minY=g,this.state.constraints.maxY=f;let y=.25;function b(u,v,p){return u<v?i?v+(u-v)*y:v:u>p?i?p+(u-p)*y:p:u}this.state.constraints.boundingX=b(t,d,m),this.state.constraints.boundingY=b(e,g,f)}f(){let{offsetX:t,offsetY:e}=this.state.movement,{minX:i,maxX:s,minY:h,maxY:o}=this.state.constraints,n=Math.max(i,Math.min(s,t)),a=Math.max(h,Math.min(o,e)),r=performance.now(),l=250,c=m=>{let d=Math.min(1,(m-r)/l),f=d*(2-d);this.state.movement.offsetX=t+(n-t)*f,this.state.movement.offsetY=e+(a-e)*f,this.t(),d<1&&requestAnimationFrame(c)};requestAnimationFrame(c)}l(t,e){let i=t.x-e.x,s=t.y-e.y;return Math.sqrt(i*i+s*s)}u(t,e){let i=this.boundary.getBoundingClientRect();return{x:(t.x+e.x)/2-i.left,y:(t.y+e.y)/2-i.top}}v(t,e,i){this.r(),this.state.isDragging=!0,this.state.movement.startX=t,this.state.movement.startY=e,this.state.primaryPointerId=i,this.state.movement.velocityX=0,this.state.movement.velocityY=0,this.state.movement.lastTime=performance.now(),this.boundary.setPointerCapture(i)}g(){let t=Array.from(this.activePointers.values());if(t.length!==2)return;this.r(),this.state.isPinching=!0,this.state.isDragging=!1;let[e,i]=t,s=this.u(e,i),h=(s.x-this.boundary.clientWidth/2-this.state.movement.offsetX)/this.state.zoom,o=(s.y-this.boundary.clientHeight/2-this.state.movement.offsetY)/this.state.zoom;this.pinchState={initialDistance:this.l(e,i),initialZoom:this.state.zoom,initialCenter:s,initialOffsetX:this.state.movement.offsetX,initialOffsetY:this.state.movement.offsetY,contentPointX:h,contentPointY:o},Array.from(this.activePointers.keys()).forEach(a=>{this.boundary.setPointerCapture(a)})}m(t){if(this.state.primaryPointerId!==t)return;let i=performance.now()-this.state.movement.lastTime;if(i>150){this.state.movement.velocityX=0,this.state.movement.velocityY=0,this.options.mode==="bounded"&&this.f();return}else i<5&&(this.state.movement.velocityX*=.5,this.state.movement.velocityY*=.5);if(this.state.isDragging=!1,this.state.primaryPointerId=-1,Math.sqrt(this.state.movement.velocityX**2+this.state.movement.velocityY**2)>this.options.inertiaThreshold,this.p(),this.boundary.hasPointerCapture(t)&&this.boundary.releasePointerCapture(t),this.options.mode==="bounded"){let{offsetX:h,offsetY:o}=this.state.movement,{minX:n,maxX:a,minY:r,maxY:l}=this.state.constraints,c=h<n||h>a,m=o<r||o>l;(c||m)&&this.f()}}c(){if(this.state.isPinching=!1,this.pinchState=null,this.activePointers.forEach((t,e)=>{this.boundary.hasPointerCapture(e)&&this.boundary.releasePointerCapture(e)}),this.options.mode==="bounded"){let{offsetX:t,offsetY:e}=this.state.movement,{minX:i,maxX:s,minY:h,maxY:o}=this.state.constraints,n=t<i||t>s,a=e<h||e>o;(n||a)&&this.f()}}e(t){t.target instanceof HTMLElement&&[this.boundary,this.target].includes(t.target)&&(this.activePointers.set(t.pointerId,{x:t.clientX,y:t.clientY,timestamp:Date.now()}),this.activePointers.size===1?this.v(t.clientX,t.clientY,t.pointerId):this.activePointers.size===2&&this.options.zoom.enabled&&this.g(),t.preventDefault())}s(t){this.activePointers.has(t.pointerId)&&this.activePointers.set(t.pointerId,{x:t.clientX,y:t.clientY,timestamp:Date.now()}),this.state.isDragging&&this.state.primaryPointerId===t.pointerId&&this.b(t.clientX,t.clientY),this.state.isPinching&&this.activePointers.size===2&&this.Y()}b(t,e){let i=performance.now(),s=(t-this.state.movement.startX)*this.options.dragSpeed,h=(e-this.state.movement.startY)*this.options.dragSpeed,o=this.state.movement.offsetX,n=this.state.movement.offsetY;this.options.mode==="bounded"?(this.d(this.state.movement.offsetX+s,this.state.movement.offsetY+h,!0),this.state.movement.offsetX=this.state.constraints.boundingX,this.state.movement.offsetY=this.state.constraints.boundingY):(this.state.movement.offsetX+=s,this.state.movement.offsetY+=h);let a=i-this.state.movement.lastTime;if(a>5&&a<100){let r=this.state.movement.offsetX-o,l=this.state.movement.offsetY-n;this.state.movement.velocityX=r/a*1e3,this.state.movement.velocityY=l/a*1e3}this.state.movement.startX=t,this.state.movement.startY=e,this.state.movement.lastTime=i,this.t()}Y(){if(!this.pinchState||this.activePointers.size!==2)return;let t=Array.from(this.activePointers.values()),[e,i]=t,h=this.l(e,i)/this.pinchState.initialDistance,o=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,this.pinchState.initialZoom*h)),n=this.u(e,i),a=n.x-this.boundary.clientWidth/2-this.pinchState.contentPointX*o,r=n.y-this.boundary.clientHeight/2-this.pinchState.contentPointY*o;this.state.zoom=o,this.state.movement.offsetX=a,this.state.movement.offsetY=r,this.t()}o(t){if(this.activePointers.delete(t.pointerId),this.state.isPinching&&this.activePointers.size<2){if(this.c(),this.activePointers.size===1){let[e]=this.activePointers.keys(),i=this.activePointers.get(e);i&&this.v(i.x,i.y,e)}}else this.state.isDragging&&this.m(t.pointerId)}n(t){this.activePointers.delete(t.pointerId),this.state.isPinching&&this.c(),this.state.isDragging&&this.m(t.pointerId)}a(t){this.state.isDragging&&this.state.primaryPointerId===t.pointerId&&this.m(t.pointerId),this.activePointers.delete(t.pointerId),this.state.isPinching&&this.activePointers.size<2&&this.c()}i(){this.state.isDragging&&this.m(this.state.primaryPointerId),this.state.isPinching&&this.c(),this.activePointers.clear()}h(t){t.preventDefault();let i=1+-t.deltaY/1e3,s=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,this.state.zoom*i));if(Math.abs(s-this.state.zoom)<.001)return;let h=this.boundary.getBoundingClientRect(),o,n;this.options.zoom.zoomTo==="cursor"?(o=t.clientX-h.left,n=t.clientY-h.top):(o=this.boundary.clientWidth/2,n=this.boundary.clientHeight/2);let a=(o-this.boundary.clientWidth/2-this.state.movement.offsetX)/this.state.zoom,r=(n-this.boundary.clientHeight/2-this.state.movement.offsetY)/this.state.zoom,l=o-this.boundary.clientWidth/2-a*s,c=n-this.boundary.clientHeight/2-r*s,m=this.options.zoom.smoothing;this.state.zoom+=(s-this.state.zoom)*m,this.state.movement.offsetX+=(l-this.state.movement.offsetX)*m,this.state.movement.offsetY+=(c-this.state.movement.offsetY)*m,this.t()}getPosition(){return{x:this.state.movement.offsetX,y:this.state.movement.offsetY}}setPosition(t,e,i=!0){i&&this.options.mode==="bounded"?(this.d(t,e),this.state.movement.offsetX=this.state.constraints.boundingX,this.state.movement.offsetY=this.state.constraints.boundingY):(this.state.movement.offsetX=t,this.state.movement.offsetY=e),this.t()}getZoom(){return this.state.zoom}setZoom(t,e=!0){let i=Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,t));if(e){let s=i-this.state.zoom;this.state.zoom+=s*this.options.zoom.smoothing}else this.state.zoom=i;this.t()}reset(){this.state.movement.offsetX=0,this.state.movement.offsetY=0,this.state.zoom=this.options.zoom.initial,this.t()}updateOptions(t){this.options={...this.options,...t,zoom:{...this.options.zoom,...t.zoom}},(this.state.zoom<this.options.zoom.min||this.state.zoom>this.options.zoom.max)&&this.setZoom(Math.max(this.options.zoom.min,Math.min(this.options.zoom.max,this.state.zoom)))}isDragging(){return this.state.isDragging}isPinching(){return this.state.isPinching}getActivePointerCount(){return this.activePointers.size}destroy(){this.r(),this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null),this.activePointers.clear(),this.pinchState=null,this.boundary.removeEventListener("pointerdown",this.e),this.boundary.removeEventListener("pointermove",this.s),this.boundary.removeEventListener("pointerup",this.o),this.boundary.removeEventListener("pointercancel",this.n),this.boundary.removeEventListener("pointerleave",this.a),this.boundary.removeEventListener("wheel",this.h),globalThis.removeEventListener("blur",this.i),globalThis.removeEventListener("visibilitychange",this.i),this.boundary.style.touchAction="",this.boundary.style.userSelect=""}};export{Y as Drifter};
