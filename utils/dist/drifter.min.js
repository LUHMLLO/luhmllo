// deno-lint-ignore-file
var X = class {
  constructor (t, i, s) {
    if (
      ((this.target = typeof t == "string" ? document.getElementById(t) : t),
        !this.target || !(this.target instanceof HTMLElement))
    ) {
      throw new Error(`Target element not found or invalid: ${ t }`)
    }
    if (
      ((this.boundary = typeof i == "string" ? document.getElementById(i) : i),
        !this.boundary || !(this.boundary instanceof HTMLElement))
    ) {
      throw new Error(`Boundary element not found or invalid: ${ i }`)
    }
    (this.options = {
      dragSpeed: 1.25,
      inertiaDamping: 0.92,
      inertiaThreshold: 1,
      mode: "bounded",
      ...s,
      zoom: {
        enabled: !0,
        initial: 1,
        min: 0.5,
        max: 1.5,
        smoothing: 0.75,
        zoomTo: "cursor",
        ...s?.zoom,
      },
    }),
      (this.state = {
        primaryPointerId: -1,
        constraints: {
          boundingX: 0,
          boundingY: 0,
          minX: 0,
          maxX: 0,
          minY: 0,
          maxY: 0,
        },
        isDragging: !1,
        isPinching: !1,
        movement: {
          offsetX: 0,
          offsetY: 0,
          startX: 0,
          startY: 0,
          velocityX: 0,
          velocityY: 0,
          lastTime: 0,
        },
        zoom: this.options.zoom.initial,
      }),
      (this.activePointers = new Map()),
      (this.pinchState = null),
      (this.animationFrameId = null),
      (this.inertiaFrameId = null),
      (this.s = this.s.bind(this)),
      (this.i = this.i.bind(this)),
      (this.e = this.e.bind(this)),
      (this.o = this.o.bind(this)),
      (this.n = this.n.bind(this)),
      this.initialize()
  }
  initialize() {
    this.boundary.addEventListener("pointerdown", this.s),
      this.boundary.addEventListener("pointermove", this.i),
      this.boundary.addEventListener("pointerup", this.e),
      this.boundary.addEventListener("pointercancel", this.o),
      this.options.zoom.enabled &&
      this.boundary.addEventListener("wheel", this.n, { passive: !1 }),
      (this.boundary.style.touchAction = "none"),
      (this.boundary.style.userSelect = "none"),
      this.t()
  }
  t() {
    this.animationFrameId && cancelAnimationFrame(this.animationFrameId),
      (this.animationFrameId = requestAnimationFrame(() => {
        this.target.style.setProperty(
          "--translate-x",
          `${ this.state.movement.offsetX }px`,
        ),
          this.target.style.setProperty(
            "--translate-y",
            `${ this.state.movement.offsetY }px`,
          ),
          this.target.style.setProperty("--translate-z", "0px"),
          this.target.style.setProperty("--scale", `${ this.state.zoom }`),
          (this.animationFrameId = null)
      }))
  }
  u() {
    if (this.state.isDragging || this.state.isPinching) return
    let t = this.options.inertiaDamping ?? 0.92,
      i = this.options.inertiaThreshold ?? 1,
      s = 2e3;
    (this.state.movement.velocityX = Math.max(
      -s,
      Math.min(s, this.state.movement.velocityX),
    )),
      (this.state.movement.velocityY = Math.max(
        -s,
        Math.min(s, this.state.movement.velocityY),
      ))
    let e = performance.now(),
      h = (o) => {
        if (!this.inertiaFrameId) return
        let n = (o - e) / 1e3;
        (e = o),
          (this.state.movement.velocityX *= Math.pow(t, n * 60)),
          (this.state.movement.velocityY *= Math.pow(t, n * 60))
        let a = this.state.movement.velocityX,
          m = this.state.movement.velocityY
        if (Math.sqrt(a * a + m * m) < i) {
          this.a()
          return
        }
        let c = a * n,
          r = m * n,
          f = this.state.movement.offsetX + c,
          d = this.state.movement.offsetY + r
        this.options.mode === "bounded" &&
          (this.h(f, d, !1),
            (f = this.state.constraints.boundingX),
            (d = this.state.constraints.boundingY),
            f !== this.state.movement.offsetX + c &&
            (this.state.movement.velocityX *= -0.3),
            d !== this.state.movement.offsetY + r &&
            (this.state.movement.velocityY *= -0.3)),
          (this.state.movement.offsetX = f),
          (this.state.movement.offsetY = d),
          this.t(),
          (this.inertiaFrameId = requestAnimationFrame(h))
      }
    this.inertiaFrameId = requestAnimationFrame(h)
  }
  a() {
    this.inertiaFrameId &&
      (cancelAnimationFrame(this.inertiaFrameId), (this.inertiaFrameId = null)),
      (this.state.movement.velocityX = 0),
      (this.state.movement.velocityY = 0)
  }
  h(t, i, s = !0) {
    let e = this.target.clientWidth * this.state.zoom,
      h = this.target.clientHeight * this.state.zoom,
      o = getComputedStyle(this.boundary),
      n = {
        left: parseFloat(o.paddingLeft),
        right: parseFloat(o.paddingRight),
        top: parseFloat(o.paddingTop),
        bottom: parseFloat(o.paddingBottom),
      },
      a = this.boundary.clientWidth - n.left - n.right,
      m = this.boundary.clientHeight - n.top - n.bottom,
      l = a / 2,
      c = m / 2,
      r = (e - a) / 2 + l,
      f = -r,
      d = (h - m) / 2 + c,
      y = -d;
    (this.state.constraints.minX = f),
      (this.state.constraints.maxX = r),
      (this.state.constraints.minY = y),
      (this.state.constraints.maxY = d)
    let g = 0.25
    function Y(u, v, p) {
      return u < v
        ? s ? v + (u - v) * g : v
        : u > p
          ? s ? p + (u - p) * g : p
          : u
    }
    (this.state.constraints.boundingX = Y(t, f, r)),
      (this.state.constraints.boundingY = Y(i, y, d))
  }
  m() {
    let { offsetX: t, offsetY: i } = this.state.movement,
      { minX: s, maxX: e, minY: h, maxY: o } = this.state.constraints,
      n = Math.max(s, Math.min(e, t)),
      a = Math.max(h, Math.min(o, i)),
      m = performance.now(),
      l = 250,
      c = (r) => {
        let f = Math.min(1, (r - m) / l),
          d = f * (2 - f);
        (this.state.movement.offsetX = t + (n - t) * d),
          (this.state.movement.offsetY = i + (a - i) * d),
          this.t(),
          f < 1 && requestAnimationFrame(c)
      }
    requestAnimationFrame(c)
  }
  r(t, i) {
    let s = t.x - i.x,
      e = t.y - i.y
    return Math.sqrt(s * s + e * e)
  }
  c(t, i) {
    let s = this.boundary.getBoundingClientRect()
    return { x: (t.x + i.x) / 2 - s.left, y: (t.y + i.y) / 2 - s.top }
  }
  f(t, i, s) {
    this.a(),
      (this.state.isDragging = !0),
      (this.state.movement.startX = t),
      (this.state.movement.startY = i),
      (this.state.primaryPointerId = s),
      (this.state.movement.velocityX = 0),
      (this.state.movement.velocityY = 0),
      (this.state.movement.lastTime = performance.now()),
      this.boundary.setPointerCapture(s)
  }
  v() {
    let t = Array.from(this.activePointers.values())
    if (t.length !== 2) return
    this.a(), (this.state.isPinching = !0), (this.state.isDragging = !1)
    let [ i, s ] = t,
      e = this.c(i, s),
      h = (e.x - this.boundary.clientWidth / 2 - this.state.movement.offsetX) /
        this.state.zoom,
      o = (e.y - this.boundary.clientHeight / 2 - this.state.movement.offsetY) /
        this.state.zoom;
    (this.pinchState = {
      initialDistance: this.r(i, s),
      initialZoom: this.state.zoom,
      initialCenter: e,
      initialOffsetX: this.state.movement.offsetX,
      initialOffsetY: this.state.movement.offsetY,
      contentPointX: h,
      contentPointY: o,
    }),
      Array.from(this.activePointers.keys()).forEach((a) => {
        this.boundary.setPointerCapture(a)
      })
  }
  d(t) {
    if (this.state.primaryPointerId !== t) return
    let s = performance.now() - this.state.movement.lastTime
    if (s > 150) {
      (this.state.movement.velocityX = 0),
        (this.state.movement.velocityY = 0),
        this.options.mode === "bounded" && this.m()
      return
    } else {
      s < 5 &&
        ((this.state.movement.velocityX *= 0.5),
          (this.state.movement.velocityY *= 0.5))
    }
    if (
      ((this.state.isDragging = !1),
        (this.state.primaryPointerId = -1),
        Math.sqrt(
          this.state.movement.velocityX ** 2 +
          this.state.movement.velocityY ** 2,
        ) > this.options.inertiaThreshold,
        this.u(),
        this.boundary.hasPointerCapture(t) &&
        this.boundary.releasePointerCapture(t),
        this.options.mode === "bounded")
    ) {
      let { offsetX: h, offsetY: o } = this.state.movement,
        { minX: n, maxX: a, minY: m, maxY: l } = this.state.constraints,
        c = h < n || h > a,
        r = o < m || o > l;
      (c || r) && this.m()
    }
  }
  l() {
    if (
      ((this.state.isPinching = !1),
        (this.pinchState = null),
        this.activePointers.forEach((t, i) => {
          this.boundary.hasPointerCapture(i) &&
            this.boundary.releasePointerCapture(i)
        }),
        this.options.mode === "bounded")
    ) {
      let { offsetX: t, offsetY: i } = this.state.movement,
        { minX: s, maxX: e, minY: h, maxY: o } = this.state.constraints,
        n = t < s || t > e,
        a = i < h || i > o;
      (n || a) && this.m()
    }
  }
  s(t) {
    t.target instanceof HTMLElement &&
      [ this.boundary, this.target ].includes(t.target) &&
      (this.activePointers.set(t.pointerId, {
        x: t.clientX,
        y: t.clientY,
        timestamp: Date.now(),
      }),
        this.activePointers.size === 1
          ? this.f(t.clientX, t.clientY, t.pointerId)
          : this.activePointers.size === 2 &&
          this.options.zoom.enabled &&
          this.v(),
        t.preventDefault())
  }
  i(t) {
    this.activePointers.has(t.pointerId) &&
      this.activePointers.set(t.pointerId, {
        x: t.clientX,
        y: t.clientY,
        timestamp: Date.now(),
      }),
      this.state.isDragging &&
      this.state.primaryPointerId === t.pointerId &&
      this.p(t.clientX, t.clientY),
      this.state.isPinching && this.activePointers.size === 2 && this.g()
  }
  p(t, i) {
    let s = performance.now(),
      e = (t - this.state.movement.startX) * this.options.dragSpeed,
      h = (i - this.state.movement.startY) * this.options.dragSpeed,
      o = this.state.movement.offsetX,
      n = this.state.movement.offsetY
    this.options.mode === "bounded"
      ? (this.h(
        this.state.movement.offsetX + e,
        this.state.movement.offsetY + h,
        !0,
      ),
        (this.state.movement.offsetX = this.state.constraints.boundingX),
        (this.state.movement.offsetY = this.state.constraints.boundingY))
      : ((this.state.movement.offsetX += e),
        (this.state.movement.offsetY += h))
    let a = s - this.state.movement.lastTime
    if (a > 5 && a < 100) {
      let m = this.state.movement.offsetX - o,
        l = this.state.movement.offsetY - n;
      (this.state.movement.velocityX = (m / a) * 1e3),
        (this.state.movement.velocityY = (l / a) * 1e3)
    }
    (this.state.movement.startX = t),
      (this.state.movement.startY = i),
      (this.state.movement.lastTime = s),
      this.t()
  }
  g() {
    if (!this.pinchState || this.activePointers.size !== 2) return
    let t = Array.from(this.activePointers.values()),
      [ i, s ] = t,
      h = this.r(i, s) / this.pinchState.initialDistance,
      o = Math.max(
        this.options.zoom.min,
        Math.min(this.options.zoom.max, this.pinchState.initialZoom * h),
      ),
      n = this.c(i, s),
      a = n.x - this.boundary.clientWidth / 2 -
        this.pinchState.contentPointX * o,
      m = n.y -
        this.boundary.clientHeight / 2 -
        this.pinchState.contentPointY * o;
    (this.state.zoom = o),
      (this.state.movement.offsetX = a),
      (this.state.movement.offsetY = m),
      this.t()
  }
  e(t) {
    if (
      (this.activePointers.delete(t.pointerId),
        this.state.isPinching && this.activePointers.size < 2)
    ) {
      if ((this.l(), this.activePointers.size === 1)) {
        let [ i ] = this.activePointers.keys(),
          s = this.activePointers.get(i)
        s && this.f(s.x, s.y, i)
      }
    } else this.state.isDragging && this.d(t.pointerId)
  }
  o(t) {
    this.activePointers.delete(t.pointerId),
      this.state.isPinching && this.l(),
      this.state.isDragging && this.d(t.pointerId)
  }
  n(t) {
    t.preventDefault()
    let s = 1 + -t.deltaY / 1e3,
      e = Math.max(
        this.options.zoom.min,
        Math.min(this.options.zoom.max, this.state.zoom * s),
      )
    if (Math.abs(e - this.state.zoom) < 0.001) return
    let h = this.boundary.getBoundingClientRect(),
      o,
      n
    this.options.zoom.zoomTo === "cursor"
      ? ((o = t.clientX - h.left), (n = t.clientY - h.top))
      : ((o = this.boundary.clientWidth / 2),
        (n = this.boundary.clientHeight / 2))
    let a = (o - this.boundary.clientWidth / 2 - this.state.movement.offsetX) /
      this.state.zoom,
      m = (n - this.boundary.clientHeight / 2 - this.state.movement.offsetY) /
        this.state.zoom,
      l = o - this.boundary.clientWidth / 2 - a * e,
      c = n - this.boundary.clientHeight / 2 - m * e,
      r = this.options.zoom.smoothing;
    (this.state.zoom += (e - this.state.zoom) * r),
      (this.state.movement.offsetX += (l - this.state.movement.offsetX) * r),
      (this.state.movement.offsetY += (c - this.state.movement.offsetY) * r),
      this.t()
  }
  getPosition() {
    return { x: this.state.movement.offsetX, y: this.state.movement.offsetY }
  }
  setPosition(t, i, s = !0) {
    s && this.options.mode === "bounded"
      ? (this.h(t, i),
        (this.state.movement.offsetX = this.state.constraints.boundingX),
        (this.state.movement.offsetY = this.state.constraints.boundingY))
      : ((this.state.movement.offsetX = t), (this.state.movement.offsetY = i)),
      this.t()
  }
  getZoom() {
    return this.state.zoom
  }
  setZoom(t, i = !0) {
    let s = Math.max(this.options.zoom.min, Math.min(this.options.zoom.max, t))
    if (i) {
      let e = s - this.state.zoom
      this.state.zoom += e * this.options.zoom.smoothing
    } else this.state.zoom = s
    this.t()
  }
  reset() {
    (this.state.movement.offsetX = 0),
      (this.state.movement.offsetY = 0),
      (this.state.zoom = this.options.zoom.initial),
      this.t()
  }
  updateOptions(t) {
    (this.options = {
      ...this.options,
      ...t,
      zoom: { ...this.options.zoom, ...t.zoom },
    }),
      (this.state.zoom < this.options.zoom.min ||
        this.state.zoom > this.options.zoom.max) &&
      this.setZoom(
        Math.max(
          this.options.zoom.min,
          Math.min(this.options.zoom.max, this.state.zoom),
        ),
      )
  }
  isDragging() {
    return this.state.isDragging
  }
  isPinching() {
    return this.state.isPinching
  }
  getActivePointerCount() {
    return this.activePointers.size
  }
  destroy() {
    this.a(),
      this.animationFrameId &&
      (cancelAnimationFrame(this.animationFrameId),
        (this.animationFrameId = null)),
      this.activePointers.clear(),
      (this.pinchState = null),
      this.boundary.removeEventListener("pointerdown", this.s),
      this.boundary.removeEventListener("pointermove", this.i),
      this.boundary.removeEventListener("pointerup", this.e),
      this.boundary.removeEventListener("pointercancel", this.o),
      this.boundary.removeEventListener("wheel", this.n),
      (this.boundary.style.touchAction = ""),
      (this.boundary.style.userSelect = "")
  }
}
export { X as Drifter }
